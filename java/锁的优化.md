#### 死锁

两个或多个线程相互占用对方需要的资源

#### 减少锁的持有时间

只在必要时进行同步，减少线程持有锁的时间，降低锁冲突的可能性，提高系统性能

#### 减小锁的粒度

例如ConcurrentHashMap分段加锁

但是当需要获取全局锁，如size()，会消耗较多的资源

#### 读写分离

ReadWriteLock

ReentrantReadWriteLock

根据读写操作功能上的不同，进行有效的锁分离；

读写分离后，读与读之间不会阻塞，但是读与写之间肯定会阻塞。

#### 锁分离

例如LinkedBlockQueue，是基于链表的，take方法作用于队列的前端，而方法put作用于尾端。

#### 锁粗化

对于一连串连续的对同一锁不断进行请求和释放，合并成对锁的一次请求，减少对锁的请求同步次数。

原因是对锁的请求、同步、释放也会消耗系统资源

#### 偏向锁

如果一个线程获得了锁，当这个线程再次请求锁时，无序做任何同步操作。

注意：对于没有竞争的场合，偏向锁有比较好的优化效果；
	但是竞争激烈的场合效果不好，应为很有可能每次都是不同的线程请求锁。

#### 轻量级锁



#### 自旋锁

避免线程真正的在操作系统层面挂起，虚拟机会让当前线程执行几个空循环；如果在执行若干空循环之后，可以得到锁，在进入临界区，如果不能获得锁，才会真正的把线程挂起

#### 锁消除

java虚拟机在JIT编译时，通过对上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。

锁消除设计的一项关键技术为**逃逸分析**，所谓逃逸分析也就是观察某个变量是否会逃出某一个作用域

#### ThreadLocal

里边的对象需要及时清理，大对象一般不要设置到ThreadLocal中

#### 


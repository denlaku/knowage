# MYSQL

## mysql安装

### 单机安装

**安装前准备**

CentOS7环境
`10.10.10.21`
安装包：
` mysql-5.7.23-el7-x86_64.tar.g`

**上传安装包至目录`/usr/local/`并解压**

```shell
cd /usr/local/
tar -xvf mysql-5.7.23-el7-x86_64.tar.g
mv mysql-5.7.23-el7-x86_64 mysql
```

**创建mysql用户组及用户，并授权**

```shell
groupadd mysql
useradd -g mysql mysql
chown -R mysql /usr/local/mysql
chgrp -R mysql /usr/local/mysql
```

**创建配置文件`my.cnf`并添加如下配置**

```shell
[client]
port=3306
socket=/tmp/mysql.sock

[mysqld]
character_set_server=utf8
init_connect='SET NAMES utf8'
basedir=/usr/local/mysql
datadir=/usr/local/mysql/data
socket=/tmp/mysql.sock
log-error=/var/log/mysqld.log
#pid-file=/var/run/mysqld/mysqld.pid
#不区分大小写
lower_case_table_names = 1
```

**初始化数据库**

```shell
#手动编辑一下日志文件，什么也不用写，直接保存退出
cd /var/log/
vim mysqld.log

chmod 777 mysqld.log
chown mysql:mysql mysqld.log

/usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --lc_messages_dir=/usr/local/mysql/share --lc_messages=en_US
```

**查看初始密码**

```shell
cat /var/log/mysqld.log
#密码在文件的最后一行
#[Note] A temporary password is generated for root@localhost: I3U#HIqPu7yv
#这安装后的初始密码是：I3U#HIqPu7yv

# 或者用如下命令查看密码
grep "password" /var/log/mysqld.log
```

**启动mysql服务，修改初始密码**

```shell
/usr/local/mysql/support-files/mysql.server start
/usr/local/mysql/bin/mysql -uroot -p
#输入密码 I3U#HIqPu7yv
set password=password('new_pwd');
grant all privileges on *.* to 'root'@'%' identified by 'new_pwd';
flush privileges;
```

**设置开机自启**

```shell
cd /usr/local/mysql/support-files
cp mysql.server /etc/init.d/mysqld
chkconfig --add mysqld
```

ln -s /usr/local/mysql/bin/mysql /usr/bin

至此单机安装已经完成。

------

### 主从复制

主库IP：`10.10.10.21`

从库IP：`10.10.10.22`

主库创建数据同步用户并授权

```sql
create user repli identified by 'new_password';
grant replication slave on *.* to 'repli'@'%' identified by 'new_password'; 
```

编辑主库my.cnf文件，添加如下内容

```shell
[mysqld]
log-bin=mysql-bin # 开启bin日志
server-id=21 #mysql服务ID(必须唯一)
```

编辑从库my.cnf文件，添加如下内容

```shell
[mysqld]
server-id=21 #mysql服务ID(必须唯一)
```

获取主库binlog文件名称及pos位置信息，执行 `show master status;`

| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
| ---------------- | -------- | ------------ | ---------------- | ----------------- |
| mysql-bin.000002 | 696      |              |                  |                   |

在从节点配置访问主节点的参数信息

```shell
change master to 
master_host='10.10.10.21',
master_user='repli',
master_password='denlaku', 
master_log_file='mysql-bin.000002',
master_log_pos=696;
```

启动从库复制，执行 `start slave;`

停止从库复制，执行  `stop slave;`

## MySql文件

### **配置文件my.cnf**

在linux中mysql的配置文件位于： /etc/my.cnf

二进制日志文件log-bin 用于主从复制

错误日志log-err 默认是关闭的，记录严重的警告和错误信息

查询日志log 默认关闭，记录查询的sql

### **数据文件**

fmt文件，存储表结构

myd文件，存储表数据

myi文件，存储索引数据

## MySql逻辑架构

## MySql存储引擎

## MySql索引

### **什么是索引？**

索引本质上是一种排好序查找快的数据结构，有助于mysql快速高效返回符合条件的数据，提高数据查找效率。

索引的优势和劣势：
**优势**：提高了数据的检索效率，降低了数据库的IO成本；通过对索引列的排序，降低数据的排序成本，降低了CPU的消耗。

**劣势**：索引实际上也是一种表，保存了主键和索引字段，并指向实体表的记录，也是需要占用磁盘空间的。同时索引也会降低更新表的速度，对insert、update、delete都有影响。因为索引字段的数据发生变化，也需要对响应的索引进行根性。索引只是提高查询速度的一个因素，对于数据量大的表，还是需要建立最优秀的索引，并且还要优化查询语句。

### **索引分类**

**单只索引**：一个索引只包含一个列，一个表可以有多个单只索引。
**唯一索引**：索引列的值必须唯一，但允许有空值。
**复合索引**：一个索引包含多个列。

### 索引语法

**创建索引**

```sql
create [unique] index indexName on tableName(column1, column2);
alter tableName add index [indexName] on(column1, column2);
```

**删除索引**

```sql
drop index [indexName] on tableName;
```

**查看索引**

```sql
show index from tableName;
```

### 需要创建索引情况

主键自动建立唯一索引；
频繁作为查询条件的字段应该创建索引；
查询中与其他表关联的字段，外键关系建立索引；
查询中排序的字段，排序字段若通过索引去访问，将大大提高排序速度；
查询中统计或分组字段；

### 不需要创建索引情况

表记录太少；
经常增删改的表；
数据重复且分布平均的字段，因为包含很多重复内容，建索引没有太大实际效果；
频繁跟新的字段不宜创建索引，因为每次跟新不仅更新了记录，还会更新索引，加重了IO负担；
where中用不到的字段不创建索引；

### 索引分类

BTree索引

Hash索引

full-text索引

R-Tree索引

### Explain

**id**

id相同，执行顺序由上而下
id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。
id相同、不同同时存在

**select_type**

SIMPLE：简单的select查询，不包含子查询或union
PRIMARY： 查询中最外层的select(如两表做union或者存在子查询的外层的表操作为PRIMARY,内层的操作为UNION)
SUBQUERY：select或where列表中的子查询
DERIVED：在from中包含的子查询
UNION：
UNION RESULT：union获得的结果集

**type**

all：全表扫描
index：全索引扫描
range：只检索给定的行，使用一个索引来选择行。一般是where中用了between, >, <, in等查询。返回扫描索引。
ref ：非唯一索引扫描，返回匹配某个单独值的所有行。
eq_ref： 唯一索引扫描，对于每一个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
const：表示通过索引一次就找到了，const用于比较primary key和unique索引。返回结果只有一行数据。
system：表只有一行记录(等于系统表)，是const类型的特例。

**possible_keys**

显示可能应用到这张表的索引，一个或多个。
查询上涉及到的字段上若存在索引，则该索引被列出，但不一定被查询实际使用

**key**

实际中使用的索引。若果为null，则没有使用索引。
若果查询中使用了覆盖索引，则索引只出现在key列表中。
**覆盖索引**：查询的字段和是建立索引的字段，也就是说select的字段从索引中就能获取，不用读取数据行；

**key_len**

表示索引中使用的字节数，可以通过该列结算查询中使用的索引长度。在不损失精确的情况下，长度越短越好。
key_len显示的值为索引字段的最大可能长度，并非实际使用长度。ken_len根据表定义计算而得，不是通过表内检索出的。

**ref**

显示了索引的哪一列被使用了，如果可能的话是一个常数。哪些列或常量被用于查找索引列上的值。

**rows**

根据表统计信息及索引选用情况，大致估算找出所需记录所要读取的行数。

**Extra**

Using filesort：对数据使用一个外部的索引排序，而不是按照表内的索引进行排序；无法利用索引完成排序的操作称“**文件排序**”。

Using temporary：使用了临时表保存中间结果，对查询结果排序时使用了临时表。常见于order by和group by。

Using index：使用了**覆盖索引**，避免访问表中的数据行。如果同时出现了Using where表明索引被用来执行索引键值的查找。

Using Where：

Using join buffer：

Impossible where：

Select tables optimized away：

distinct：
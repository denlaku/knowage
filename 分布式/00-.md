## 分布式事务

### 什么是事务

事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。

#### 事务特性

事务具有4个特性：**原子性、一致性、隔离性、持久性**。这四个属性通常称为 **ACID** 特性。
**原子性（atomicity）：**
​	一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。
**一致性（consistency）：**
​	事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
**隔离性（isolation）：**
​	一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
**持久性（durability）：**
​	持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

#### 事务中数据读取的问题

- **脏读**：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- **不可重复读**：是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
- **虚读（幻读）**：是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
  幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

#### mysql四种隔离级别

+ Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

+ Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

+ Read committed (读已提交)：可避免脏读的发生。

+ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

```sql
-- 在MySQL数据库中查看当前事务的隔离级别：
select @@tx_isolation;
-- 在MySQL数据库中设置事务的隔离级别：
set  [glogal | session]  transaction isolation level '隔离级别名称';
set tx_isolation='隔离级别名称';
-- 设置数据库的隔离级别一定要是在开启事务之前
-- 隔离级别的设置只对当前链接有效
```

#### 事务三种模型

+ **隐式事务**是指每一条数据操作语句都自动地成为一个事务，事务的开始是隐式的，事务的结束有明确的
  标记。
+ **显式事务**是指有显式的开始和结束标记的事务，每个事务都有显式的开始和结束标记。
+ **自动事务**是系统自动默认的，开始和结束不用标记，不用并发控制

#### 分布式事务

现实中，由于数据库的性能瓶颈需要分库分表，或者分布式系统结构中调用多个“服务”并操作多个数据库或分片，这个时候就产生了分布式事务，而数据库只能实现本地事务。

一个业务要跨多个数据库，但是这些操作又需要在一个事物中完成，这种事务即为“**分布式事务**”。

#### 分布式事务理论

当出现一个事物要操作多数据库的时候（分布式事物），单个数据库的ACID已经不适用了。集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区。

刚性事务：操作资源的

柔性事务：操作数据业务代码

##### CAP定理

+ C  一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)
+ A  可用性(Availability) ： 每个操作都必须以可预期的响应结束
+ P  分区容错性(Partition tolerance)： 即使出现单个组件无法可用，操作依然可以完成

##### BASE理论

BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性（Eventual consistency）。

+ **BA：Basic Available 基本可用**；整个系统在某些不可抗力的情况下，仍然能够保证“可用性”
  **基本可用**和**高可用**的区别：
  “一定时间”可以适当延长，比如当举行大促时，响应时间可以适当延长；
  给部分用户直接返回一个降级页面，从而缓解服务器压力。但返回降级页面仍然是返回明确结果。
+ **S：Soft State：柔性状态；**同一数据的不同副本的状态，可以不需要实时一致。
+ **E：Eventual Consisstency：最终一致性；**同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。

##### 酸碱平衡

要根据具体业务场景，在ACID和BASE之间寻求平衡。“CAP定律”、“Base理论”，非常巧的是，化学理论中ACID是酸、Base恰好是碱。这种平衡叫做酸碱平衡

#### 分布式事物协议

在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。

#### XA 规范

X/Open 组织（即现在的 Open Group ）定义了**分布式事务处理模型**。 X/Open **DTP** 模型（ 1994 ）包括**应用程序**（ AP ）、**事务管理器**（ TM ）、**资源管理器**（ RM ）、**通信资源管理器**（ CRM ）四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。

通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。 所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务。例如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。

#### 分布式事物解决方案

##### 全局事务

优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。

##### 本地消息表

本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。

基本思路就是：
消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。

优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。
缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

##### 最大努力通知（定期校对）

最大努力通知也被称为定期校对，其实在方案二中已经包含了。
相比于第二种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。

##### TCC（补偿事务）

TCC 其实就是采用的补偿机制，核心思想：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

+ Try 阶段主要是对业务系统做检测及资源预留
+ Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
+ Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。

##### MQ 事务消息

https://www.jianshu.com/p/453c6e7ff81c

优点： 实现了最终一致性，不需要依赖本地数据库事务。
缺点： 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。

##### Sagas 事务模型



tcc-transaction：https://github.com/changmingxie/tcc-transaction  
EasyTransaction：https://github.com/QNJR-GROUP/EasyTransaction 
LCN：https://www.txlcn.org/ 
​     https://github.com/codingapi/tx-lcn/ 
Raincat：https://github.com/yu199195/Raincat 
hmily：https://github.com/yu199195/hmily 
myth：https://github.com/yu199195/myth 







